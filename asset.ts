// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.26.1
// source: asset.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Denom } from "./domain/denom/denom";
import { Audit } from "./sologenic/com-fs-utils-lib/models/audit/audit";
import { MetaData } from "./sologenic/com-fs-utils-lib/models/metadata/metadata";

export const protobufPackage = "asset";

export enum AssetStatus {
  ASSET_STATUS_DO_NOT_USE = 0,
  /** DO_NOT_LIST - BROKER_ASSET_ADMINISTRATOR only */
  DO_NOT_LIST = 1,
  /** REQUEST_LISTING - BROKER_ASSET_ADMINISTRATOR only */
  REQUEST_LISTING = 2,
  /** LISTED - ORGANIZATION_ASSET_ADMINISTRATOR only */
  LISTED = 3,
  /** ORGANIZATION_ADMIN_DO_NOT_LIST - ORGANIZATION_ASSET_ADMINISTRATOR only */
  ORGANIZATION_ADMIN_DO_NOT_LIST = 4,
  OUTDATED_ASSET_VERSION = 5,
  UNRECOGNIZED = -1,
}

export function assetStatusFromJSON(object: any): AssetStatus {
  switch (object) {
    case 0:
    case "ASSET_STATUS_DO_NOT_USE":
      return AssetStatus.ASSET_STATUS_DO_NOT_USE;
    case 1:
    case "DO_NOT_LIST":
      return AssetStatus.DO_NOT_LIST;
    case 2:
    case "REQUEST_LISTING":
      return AssetStatus.REQUEST_LISTING;
    case 3:
    case "LISTED":
      return AssetStatus.LISTED;
    case 4:
    case "ORGANIZATION_ADMIN_DO_NOT_LIST":
      return AssetStatus.ORGANIZATION_ADMIN_DO_NOT_LIST;
    case 5:
    case "OUTDATED_ASSET_VERSION":
      return AssetStatus.OUTDATED_ASSET_VERSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetStatus.UNRECOGNIZED;
  }
}

export function assetStatusToJSON(object: AssetStatus): string {
  switch (object) {
    case AssetStatus.ASSET_STATUS_DO_NOT_USE:
      return "ASSET_STATUS_DO_NOT_USE";
    case AssetStatus.DO_NOT_LIST:
      return "DO_NOT_LIST";
    case AssetStatus.REQUEST_LISTING:
      return "REQUEST_LISTING";
    case AssetStatus.LISTED:
      return "LISTED";
    case AssetStatus.ORGANIZATION_ADMIN_DO_NOT_LIST:
      return "ORGANIZATION_ADMIN_DO_NOT_LIST";
    case AssetStatus.OUTDATED_ASSET_VERSION:
      return "OUTDATED_ASSET_VERSION";
    case AssetStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Reason {
  REASON_DO_NOT_USE = 0,
  DUPLICATE = 1,
  UNWANTED_ASSET = 2,
  UNSTABLE_ASSET = 3,
  UNRECOGNIZED = -1,
}

export function reasonFromJSON(object: any): Reason {
  switch (object) {
    case 0:
    case "REASON_DO_NOT_USE":
      return Reason.REASON_DO_NOT_USE;
    case 1:
    case "DUPLICATE":
      return Reason.DUPLICATE;
    case 2:
    case "UNWANTED_ASSET":
      return Reason.UNWANTED_ASSET;
    case 3:
    case "UNSTABLE_ASSET":
      return Reason.UNSTABLE_ASSET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Reason.UNRECOGNIZED;
  }
}

export function reasonToJSON(object: Reason): string {
  switch (object) {
    case Reason.REASON_DO_NOT_USE:
      return "REASON_DO_NOT_USE";
    case Reason.DUPLICATE:
      return "DUPLICATE";
    case Reason.UNWANTED_ASSET:
      return "UNWANTED_ASSET";
    case Reason.UNSTABLE_ASSET:
      return "UNSTABLE_ASSET";
    case Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AssetType {
  ASSET_TYPE_DO_NOT_USE = 0,
  STOCK = 1,
  BOND = 2,
  UNRECOGNIZED = -1,
}

export function assetTypeFromJSON(object: any): AssetType {
  switch (object) {
    case 0:
    case "ASSET_TYPE_DO_NOT_USE":
      return AssetType.ASSET_TYPE_DO_NOT_USE;
    case 1:
    case "STOCK":
      return AssetType.STOCK;
    case 2:
    case "BOND":
      return AssetType.BOND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetType.UNRECOGNIZED;
  }
}

export function assetTypeToJSON(object: AssetType): string {
  switch (object) {
    case AssetType.ASSET_TYPE_DO_NOT_USE:
      return "ASSET_TYPE_DO_NOT_USE";
    case AssetType.STOCK:
      return "STOCK";
    case AssetType.BOND:
      return "BOND";
    case AssetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Exchange {
  EXCHANGE_DO_NOT_USE = 0,
  NASDAQ = 1,
  NYSE = 2,
  UNRECOGNIZED = -1,
}

export function exchangeFromJSON(object: any): Exchange {
  switch (object) {
    case 0:
    case "EXCHANGE_DO_NOT_USE":
      return Exchange.EXCHANGE_DO_NOT_USE;
    case 1:
    case "NASDAQ":
      return Exchange.NASDAQ;
    case 2:
    case "NYSE":
      return Exchange.NYSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Exchange.UNRECOGNIZED;
  }
}

export function exchangeToJSON(object: Exchange): string {
  switch (object) {
    case Exchange.EXCHANGE_DO_NOT_USE:
      return "EXCHANGE_DO_NOT_USE";
    case Exchange.NASDAQ:
      return "NASDAQ";
    case Exchange.NYSE:
      return "NYSE";
    case Exchange.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AssetDetails {
  /** Key combination: Currency-OrganizationID */
  ID: string;
  /** External entity (broker) that owns this asset */
  OrganizationID: string;
  Status: AssetStatus;
  Reason?:
    | Reason
    | undefined;
  /** list of jurisdictionIDs where this asset is allowed to be traded */
  JurisdictionIDs: string[];
  Type: AssetType;
  /** Asset specific properties */
  Name: string;
  ExchangeTickerSymbol: string;
  Exchange: Exchange;
  /** Description for internal use, not for on-chain */
  InternalDescription: string;
  MinTransactionAmount: number;
  /** Extra margin percentage required when buying an asset. e.g ExtraPercentage = 0.1 the buyer must provide 10% extra marginâ€”of which the cost is 5%, and the remaining 5% is returned to the buyer. */
  ExtraPercentage: number;
  /** On-chain properties */
  Denom:
    | Denom
    | undefined;
  /** Flag to indicate if the asset is issued in the smart contract */
  IsIssuedInSmartContract: boolean;
}

export interface Asset {
  AssetDetails: AssetDetails | undefined;
  MetaData: MetaData | undefined;
  Audit: Audit | undefined;
}

export interface Assets {
  Assets: Asset[];
}

function createBaseAssetDetails(): AssetDetails {
  return {
    ID: "",
    OrganizationID: "",
    Status: 0,
    Reason: undefined,
    JurisdictionIDs: [],
    Type: 0,
    Name: "",
    ExchangeTickerSymbol: "",
    Exchange: 0,
    InternalDescription: "",
    MinTransactionAmount: 0,
    ExtraPercentage: 0,
    Denom: undefined,
    IsIssuedInSmartContract: false,
  };
}

export const AssetDetails = {
  encode(message: AssetDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ID !== "") {
      writer.uint32(10).string(message.ID);
    }
    if (message.OrganizationID !== "") {
      writer.uint32(18).string(message.OrganizationID);
    }
    if (message.Status !== 0) {
      writer.uint32(24).int32(message.Status);
    }
    if (message.Reason !== undefined) {
      writer.uint32(32).int32(message.Reason);
    }
    for (const v of message.JurisdictionIDs) {
      writer.uint32(42).string(v!);
    }
    if (message.Type !== 0) {
      writer.uint32(48).int32(message.Type);
    }
    if (message.Name !== "") {
      writer.uint32(58).string(message.Name);
    }
    if (message.ExchangeTickerSymbol !== "") {
      writer.uint32(66).string(message.ExchangeTickerSymbol);
    }
    if (message.Exchange !== 0) {
      writer.uint32(72).int32(message.Exchange);
    }
    if (message.InternalDescription !== "") {
      writer.uint32(82).string(message.InternalDescription);
    }
    if (message.MinTransactionAmount !== 0) {
      writer.uint32(89).double(message.MinTransactionAmount);
    }
    if (message.ExtraPercentage !== 0) {
      writer.uint32(97).double(message.ExtraPercentage);
    }
    if (message.Denom !== undefined) {
      Denom.encode(message.Denom, writer.uint32(138).fork()).ldelim();
    }
    if (message.IsIssuedInSmartContract !== false) {
      writer.uint32(144).bool(message.IsIssuedInSmartContract);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.OrganizationID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Reason = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.JurisdictionIDs.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.Type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ExchangeTickerSymbol = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.Exchange = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.InternalDescription = reader.string();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.MinTransactionAmount = reader.double();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.ExtraPercentage = reader.double();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.Denom = Denom.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.IsIssuedInSmartContract = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetDetails {
    return {
      ID: isSet(object.ID) ? globalThis.String(object.ID) : "",
      OrganizationID: isSet(object.OrganizationID) ? globalThis.String(object.OrganizationID) : "",
      Status: isSet(object.Status) ? assetStatusFromJSON(object.Status) : 0,
      Reason: isSet(object.Reason) ? reasonFromJSON(object.Reason) : undefined,
      JurisdictionIDs: globalThis.Array.isArray(object?.JurisdictionIDs)
        ? object.JurisdictionIDs.map((e: any) => globalThis.String(e))
        : [],
      Type: isSet(object.Type) ? assetTypeFromJSON(object.Type) : 0,
      Name: isSet(object.Name) ? globalThis.String(object.Name) : "",
      ExchangeTickerSymbol: isSet(object.ExchangeTickerSymbol) ? globalThis.String(object.ExchangeTickerSymbol) : "",
      Exchange: isSet(object.Exchange) ? exchangeFromJSON(object.Exchange) : 0,
      InternalDescription: isSet(object.InternalDescription) ? globalThis.String(object.InternalDescription) : "",
      MinTransactionAmount: isSet(object.MinTransactionAmount) ? globalThis.Number(object.MinTransactionAmount) : 0,
      ExtraPercentage: isSet(object.ExtraPercentage) ? globalThis.Number(object.ExtraPercentage) : 0,
      Denom: isSet(object.Denom) ? Denom.fromJSON(object.Denom) : undefined,
      IsIssuedInSmartContract: isSet(object.IsIssuedInSmartContract)
        ? globalThis.Boolean(object.IsIssuedInSmartContract)
        : false,
    };
  },

  toJSON(message: AssetDetails): unknown {
    const obj: any = {};
    if (message.ID !== "") {
      obj.ID = message.ID;
    }
    if (message.OrganizationID !== "") {
      obj.OrganizationID = message.OrganizationID;
    }
    if (message.Status !== 0) {
      obj.Status = assetStatusToJSON(message.Status);
    }
    if (message.Reason !== undefined) {
      obj.Reason = reasonToJSON(message.Reason);
    }
    if (message.JurisdictionIDs?.length) {
      obj.JurisdictionIDs = message.JurisdictionIDs;
    }
    if (message.Type !== 0) {
      obj.Type = assetTypeToJSON(message.Type);
    }
    if (message.Name !== "") {
      obj.Name = message.Name;
    }
    if (message.ExchangeTickerSymbol !== "") {
      obj.ExchangeTickerSymbol = message.ExchangeTickerSymbol;
    }
    if (message.Exchange !== 0) {
      obj.Exchange = exchangeToJSON(message.Exchange);
    }
    if (message.InternalDescription !== "") {
      obj.InternalDescription = message.InternalDescription;
    }
    if (message.MinTransactionAmount !== 0) {
      obj.MinTransactionAmount = message.MinTransactionAmount;
    }
    if (message.ExtraPercentage !== 0) {
      obj.ExtraPercentage = message.ExtraPercentage;
    }
    if (message.Denom !== undefined) {
      obj.Denom = Denom.toJSON(message.Denom);
    }
    if (message.IsIssuedInSmartContract !== false) {
      obj.IsIssuedInSmartContract = message.IsIssuedInSmartContract;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetDetails>, I>>(base?: I): AssetDetails {
    return AssetDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetDetails>, I>>(object: I): AssetDetails {
    const message = createBaseAssetDetails();
    message.ID = object.ID ?? "";
    message.OrganizationID = object.OrganizationID ?? "";
    message.Status = object.Status ?? 0;
    message.Reason = object.Reason ?? undefined;
    message.JurisdictionIDs = object.JurisdictionIDs?.map((e) => e) || [];
    message.Type = object.Type ?? 0;
    message.Name = object.Name ?? "";
    message.ExchangeTickerSymbol = object.ExchangeTickerSymbol ?? "";
    message.Exchange = object.Exchange ?? 0;
    message.InternalDescription = object.InternalDescription ?? "";
    message.MinTransactionAmount = object.MinTransactionAmount ?? 0;
    message.ExtraPercentage = object.ExtraPercentage ?? 0;
    message.Denom = (object.Denom !== undefined && object.Denom !== null) ? Denom.fromPartial(object.Denom) : undefined;
    message.IsIssuedInSmartContract = object.IsIssuedInSmartContract ?? false;
    return message;
  },
};

function createBaseAsset(): Asset {
  return { AssetDetails: undefined, MetaData: undefined, Audit: undefined };
}

export const Asset = {
  encode(message: Asset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.AssetDetails !== undefined) {
      AssetDetails.encode(message.AssetDetails, writer.uint32(10).fork()).ldelim();
    }
    if (message.MetaData !== undefined) {
      MetaData.encode(message.MetaData, writer.uint32(18).fork()).ldelim();
    }
    if (message.Audit !== undefined) {
      Audit.encode(message.Audit, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.AssetDetails = AssetDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.MetaData = MetaData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.Audit = Audit.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      AssetDetails: isSet(object.AssetDetails) ? AssetDetails.fromJSON(object.AssetDetails) : undefined,
      MetaData: isSet(object.MetaData) ? MetaData.fromJSON(object.MetaData) : undefined,
      Audit: isSet(object.Audit) ? Audit.fromJSON(object.Audit) : undefined,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.AssetDetails !== undefined) {
      obj.AssetDetails = AssetDetails.toJSON(message.AssetDetails);
    }
    if (message.MetaData !== undefined) {
      obj.MetaData = MetaData.toJSON(message.MetaData);
    }
    if (message.Audit !== undefined) {
      obj.Audit = Audit.toJSON(message.Audit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Asset>, I>>(base?: I): Asset {
    return Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Asset>, I>>(object: I): Asset {
    const message = createBaseAsset();
    message.AssetDetails = (object.AssetDetails !== undefined && object.AssetDetails !== null)
      ? AssetDetails.fromPartial(object.AssetDetails)
      : undefined;
    message.MetaData = (object.MetaData !== undefined && object.MetaData !== null)
      ? MetaData.fromPartial(object.MetaData)
      : undefined;
    message.Audit = (object.Audit !== undefined && object.Audit !== null) ? Audit.fromPartial(object.Audit) : undefined;
    return message;
  },
};

function createBaseAssets(): Assets {
  return { Assets: [] };
}

export const Assets = {
  encode(message: Assets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Assets) {
      Asset.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Assets {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Assets.push(Asset.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assets {
    return { Assets: globalThis.Array.isArray(object?.Assets) ? object.Assets.map((e: any) => Asset.fromJSON(e)) : [] };
  },

  toJSON(message: Assets): unknown {
    const obj: any = {};
    if (message.Assets?.length) {
      obj.Assets = message.Assets.map((e) => Asset.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Assets>, I>>(base?: I): Assets {
    return Assets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Assets>, I>>(object: I): Assets {
    const message = createBaseAssets();
    message.Assets = object.Assets?.map((e) => Asset.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
